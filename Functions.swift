/*
FUNCTIONS
 
 1. Все входные параметры функции константы, что бы их менять, нужно присвоить их значение переменной внутри
    функции.
 2. У одной функции может быть только один вариативный парамерт, и он всегда должен назодится в конце.
 3. Функция, которая принимает не более одного параметра, — это замечательно. Функции с двумя или тремя
    параметрами — у вас должны быть серьезныепричины для того, чтобы реализовать ее.
 4. При функциональном типе (Int, Int) -> Int и передаче в неё двух функций
    returnSomeNum(getPiNum(n), getFibNum(n)) вычисление каждой функции будут происходить в момент передачи
    и выпаолнено будет обо вычисления. Что бы экономить ресурсы компютера, можно изменить функциональный
    тип нам ((Int) -> Int, (Int) ->Int) -> Int и тогда будут переданы не результаты вычислни функций,
    а свми функции и вычислятся они уже будут внутри по востребованности.
 5. Функции могут быть вложенными в другие фенуции и тогда область их видимости будет ограничена
    родительской функцией.
 6. Перегружать функции (overloading) это когда в одной области видимости находятся функции с одинаковым
    именем, но разными типами.
    func say(what: String) -> Void {}
    func say(what: Int) -> Void {}
    Но в таком случае если мы инициализируем одну из этих функций/значение какой-либо переменной, мы
    должны явно указать тип переменной соответствуюзий типу функции/взовразаемого значения.
 7. Рекурсивная функция это функция которая вызывает саму себя
     func countdown(firstNum num: Int) -> Void {
         print(num)
         if num > 0 {
             countdown(firstNum:num-1)
         }
     }
 
 
 Обявление функции:
 
     func myFunc() {
        телоФункции
     }
 
 
     func myFunc() -> () {
        телоФункции
     }
 
 
     func myFunc() -> Void {
        телоФункции
     }
  
 
     func myFunc(a: Int, b: String) {
        телоФункции
     }
     
     
     func myFunc() -> [(String,Int)?] {
        телоФункции
        return ...
     }
   
 
     func myFunc(a: Int, b: String) -> [(String,Int)?] {
        телоФункции
        return ...
     }
 
 
     func getCodeDescription(code: Int) -> (Int, String) {  Можно вернуть кортеж.
         телоФункции
         return (значение Инт, значениеСтринг)
     }
 
 
     func getCodeDescription(code: Int) -> (имя1: Int, имя2: String) { В кортеже можно указать имена значений
                                                                       и потом использовать.
         телоФункции
         return (значение Инт, значениеСтринг)
     }
     let request = getCodeDescription(code: 45)
     request.description                                    // "Error"
     request.code                                           // 45
    
 
     func sumTwoInt(num1 a: Int, num2 b: Int) {             num1 и num2 - это внешние имена при вызове функции,
                                                            а a и b - это внутриннеие имена используемые в теле
                                                            функции.
         print("Результат операции - \(a+b)")
     }
     sumTwoInt(num1: 10, num2: 12)                          Вызов данной функции.
     
 
     func sumTwoInt(_ a: Int, _ b: Int) {                   Можно проигнорировать внешние имена.
         print("Результат операции - \(a+b)")
     }
     sumTwoInt(10, 12)                                      Вызов данной функции.
 
 
     func sumTwoInt(_ a: input Int, _ b: Int) {             Модификатор input позволяет изменять параметр
                                                            передаваемый в функцию, это всёравно, как передать
                                                            указатель.
         print("Результат операции - \(a+b)")
     }
 
 
     func printRequestString(codes: Int...) -> Void {       Функция с переменным числом однотипных операторов.
         var codesString = ""
         for oneCode in codes {                             В данном случае параметр code это последовательность.
             codesString += String(oneCode) + " "
         }
         print("Получены ответы — \(codesString)")
     }
     printRequestString(codes: 600, 800, 301)               // Получены ответы — 600 800 301
     printRequestString(codes: 101, 200)                    // Получены ответы — 101 200
 
 
     func returnMessage(code: Int, message: String = "Код - ") -> String {  Можно задать значение по умолчанию,
                                                                            которое будет испольховаться в
                                                                            случае не передачи аргумента.
         телоФункции
         return mutableMessage
     }
 
 
    sumWallet(banknotesFunction: generateWallet, walletLength: 20)  При передачи функции в функцию название
                                                                    функции указывается без скобок. А тип
                                                                    указывается функциональный.
 
Функциональный тип:
 () -> Void                                    Нет аргументов, Нет возвращаемого знаяения.
 () -> ()
 
 ([Int]) -> String?                            Вход: массив интов, Выход: стринг опциональный.
 
 () -> () -> Void                              Нет аргументов, Выход: функция ни чего не возврящающая.
 
 (Int) -> (String) -> Bool                     Вход: инт, Выход: функция принемеющая стринг и возвращающая бул.
 
 (Int, (Int) -> Void) -> Bool                  Вход: инт и функция принемающая инт и возвращающая Void, Выход: бул.
 
 
 func printText() {                                    Функция вызывается не в момент её инициализации переменной,
     print("Функция вызвана")                          а в момент вызова это переменной, по этому фраза
 }                                                     "Функция вызвана" находится между шагами 2 и 3, а не шагами
                                                       1 и 2.
 func returnPrintTextFunction() -> () -> Void {
     return printText                                  Что бы вернуть функцию в теле функции нужно указать её имя
 }                                                     без скобок после return.
 print("шаг 1")
 let newFunctionInLet = returnPrintTextFunction()
 print("шаг 2")
 newFunctionInLet()
 print("шаг 3")
 
 Консоль
 шаг 1
 шаг 2
 Функция вызвана
 шаг 3
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 */
