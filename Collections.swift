/*
COLLECTIONS
 
 Array===================================================================
    
 1. Упорядоченый набор элементов одного типа, каждый из которых может встречаться много раз.
 2. Массив является значимым типом (value type), а не ссылочным (reference type).
    Это означает, что при передаче значения массива из одного параметра в другой
    создается его копия, редактирование которой не влияет на исходную коллекцию.
 3. Некоторые методы возвращают массив типа arraySlice<тип>, в получившемся массиве индексы
    элементов могут начинатся не с нуля, что бы это исправить нужно явно указать тип нового
    массива например    : Array<Int>.
 
Обявление и инициализация:
    var friendsNames = ["Alexey", "Oleg", "Vitaliy", "Anatoliy", "Taras", "Evgeniy", "Valentina"]
    let numbers: [Int] = [2, 5, 7, 3, 5]
    let arrayOne: Array<Character> = ["a", "b", "c"]
    let newAlphabetArray = Array(arrayLiteral: "a", "b", "c")
    var arr = Array(0...11)
    var arr = Array(repeating: 3, count: 5)  Вернет массив из пяти троек.
    let emptyArray: [String] = []       Создаем пустой масси.
    let emptyArray = [String]()         Создаем пустой масси.
    var num: [Double]   Проинициализировать любое колличество эллементов массиву, можно будет потом.
    var arrayOfArrays = [[1,2,3], [4,5,6], [7,8,9]]
 
Доступ к элементам массива:
    number[2]                           // 7
    number[1...3]                       // [5, 7, 3] (так же можно перезаписать группу)
    number[1...3] = [8]                 Вместо 2,3,4-ого элементов создаст один со значением 8
    arrayOfArrays[2][1]                 // 8
    numbers[numbers.count - 1]          // Доступ к предпоследнему элементу массива.
 
Операции с массивами:
        Сравнение:
    let a1 = 1, a2 = 2, a3 = 3          Сравнение массивов происзодит, как сравнение строк.
    var someArray = [1, 2, 3]
    someArray == [a1, a2, a3] // true
        Слияние:
    var arr1 = ["d", "e", "f"]
    var arr2 = ["a", "b", "c"]
    var arr3 = arr1 + arr2    // ["d", "e", "f", "a", "b", "c"]
 
 
Методы:
    .append(значение)                   Добавления занчения в конец массива.
    .insert(значение, at: 2)            Добавление значения в качестве третьего элемента.
    .remove(at: 4)                      Удаляет элемент по заданному индексу.
    .removeFirst()                      Удалит первый элемент
    .removeLast()                       Удалит последний элемент
    .count                              Возвращает колличество эллементов.
    .isEmpty                            Возвращает true если массив пуст и false сли нет.
    .max()                              Максимальный элемент
    .min()                              Минимальный элемент
    .forEach {переменная in действие}   Замыкание, которое перебирает переменные и применяе к каждой действие
        friendsNames.forEach { fr in print("\(fr) still my friend") }
    .suffix(3)                          Вернет массив состоящий из трёх последних элементов.
    .first                              Вернет первый элемент массива
    .last                               Вернет последний элемент массива
    .dropFirst()                        Вернет миссив без первого элемента (не меняет исходный массив)
    .dropLast(4)                        Вернет миссив без 4 последних элементов (не меняет исходный массив)
    .contains(элемент)                  Проверяет наличие данного элемента. (возвращает true или false)
    .sort()                             Сортирует оригинальный массив по возрастанию.
    .sorted()                           Возвращает отсортированный массив не меняю оригинального.
    .randomElement()                    Вернет случайный элемент массива.
 
 
 
 Set=====================================================================
    
 1. Неупорядоченый набор элементов одного типа, каждый из которых может встречаться только один раз.

Обявление и инициализация:
    var evenNumbers = Set([2, 4, 6, 8])
    let oddNumbers: set = [1, 3, 5, 7, 9, 9]
 
Методы:
    .insert(значение)                   Добавляет значение если его еще нет в множестве иначе ничего не произойдет.
    .remove(занчение)                   Удаляет значение если его еще нет в множестве иначе ничего не произойдет.
 
 
 
 Dictionary==============================================================
 
1. Неупорядоченный набор пар (ключ: значение)
 
Обявление и инициализация:
    var scores = ["Paris": 5, "Marina": 10, "Tim": 9, "Jon": 14]
    var scores: [String: Int] = ["Paris": 5, "Marina": 10, "Tim": 9, "Jon": 14]
    var scores: [String: Int] = [:]
 
    scores["Bob"] = 17
    print(scores["Paris"]!)                // 5
 
Методы:
    .scores.updateValue(17, forKey: "Bob") Добавляем или изменяем существующее значение.
 
 
 
 Tuples==================================================================
 
1. Упорядоченый набор элементов одного или разных типов, типы и колличесво которых известны зарание.
2. Не рекомендуется использовать более 4 значений.
3. Сравнение картежа произвонится в случае если типы его элементов являются Comparable и они идентичны
   и сравнение происходит начиная с первого элемента пока не будут достигнуты разные элементы.
 
Обявление и инициализация:
    let props = (22, "age")                В данном случае можно обратиться к элементам кортежа
                                           по номеру, как в массиве point.0    // 22
    var userInfo: (Bool, Int, String) = (true, 34, "Tom")
    var userInfo: (status: Bool, age: Int, name: String) = (true, 34, "Tom")
    var point(x: 2, y: 8)                  В данном случае можно обратиться к элементам кортежа,
                                           как по номеру, так и по псевдониму point.y    // 8
    var point1: (Int, Int) = point         Однотипные картежи можно инициализировать доруг другу.
 
Передача значений элементов картежв в другие параметры:
    var (isHomeless, age, name) = userInfo Передаст в каждую переменную значение в соответствии
                                           с очередностью
    var (isHomeless, _, name) = userInfo  В данном случае элемент age будет проигнорирован.
 
Методы:
 
 
 
 Range===================================================================
 
1. Диапазон МОЖНО сравнить на эквивалентность == или !=, но НЕЛЬЗЯ сравнить >, <, >=, <=
 
Обявление и инициализация:
    let someRangeInt: Range<Int> = 1..<10
    let someRangeInt = 1..<10
    let someRangeInt: Range<Double> = 1..<10
    let someRangeInt = 1.2..<10.7
    let range = UInt8(1)...                // от 1 до +inf (но не более 255 иначе ошибка)
 
    1...4                                  // 1, 2, 3, 4
    1..<5                                  // 1, 2, 3, 4
    ...43                                  // от -inf до 43
    -21...                                 // от -21 до +inf
    переменная1...переменная2              // от переменная1 до переменная2
 
Методы:
    .contains(32)                          Проверяет содержит ли диапазон число 32.
    .count                                 Определяет колличество элементов.
                                           (только целочисленный диапазон)
    .isEmpty                               Вернет true только в полуоткрытом диапазоне
                                           0..<0 или 23..<23
    .lowerBound                            Нижняя граница
    .upperBound                            Верхняя граница (и если ..<12 и если ...12)    //12
    .min()                                 Минимальное значение (только целочисленный диапазон)
    .max()                                 Максимальное значение (только целочисленный диапазон)
 

 
 */

