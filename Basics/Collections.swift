/*
COLLECTIONS
 
 Array===================================================================
    
 1. Упорядоченый набор элементов одного типа, каждый из которых может встречаться много раз.
 2. Массив является значимым типом (value type), а не ссылочным (reference type).
    Это означает, что при передаче значения массива из одного параметра в другой
    создается его копия, редактирование которой не влияет на исходную коллекцию.
 3. Некоторые методы возвращают массив типа arraySlice<тип>, в получившемся массиве индексы
    элементов могут начинатся не с нуля, что бы это исправить нужно явно указать тип нового
    массива например    : Array<Int>.
 
Обявление и инициализация:
    var friendsNames = ["Alexey", "Oleg", "Vitaliy", "Anatoliy", "Taras", "Evgeniy", "Valentina"]
    let numbers: [Int] = [2, 5, 7, 3, 5]
    let arrayOne: Array<Character> = ["a", "b", "c"]
    let newAlphabetArray = Array(arrayLiteral: "a", "b", "c")
    var arr = Array(0...11)
    var arr = Array(repeating: 3, count: 5)  Вернет массив из пяти троек.
    let emptyArray: [String] = []       Создаем пустой масси.
    let emptyArray = [String]()         Создаем пустой масси.
    var num: [Double]   Проинициализировать любое колличество эллементов массиву, можно будет потом.
    var arrayOfArrays = [[1,2,3], [4,5,6], [7,8,9]]
 
Доступ к элементам массива:
    number[2]                           // 7
    number[1...3]                       // [5, 7, 3] (так же можно перезаписать группу)
    number[1...3] = [8]                 Вместо 2,3,4-ого элементов создаст один со значением 8
    arrayOfArrays[2][1]                 // 8
    numbers[numbers.count - 1]          // Доступ к предпоследнему элементу массива.
 
Операции с массивами:
        Сравнение:
    let a1 = 1, a2 = 2, a3 = 3          Сравнение массивов происзодит, как сравнение строк.
    var someArray = [1, 2, 3]
    someArray == [a1, a2, a3] // true
        Слияние:
    var arr1 = ["d", "e", "f"]
    var arr2 = ["a", "b", "c"]
    var arr3 = arr1 + arr2    // ["d", "e", "f", "a", "b", "c"]
 
 
Методы:
    .append(значение)                   Добавления занчения в конец массива.
    .insert(значение, at: 2)            Добавление значения в качестве третьего элемента.
    .remove(at: 4)                      Удаляет элемент по заданному индексу.
    .removeFirst()                      Удалит первый элемент
    .removeLast()                       Удалит последний элемент
    .count                              Возвращает колличество эллементов.
    .isEmpty                            Возвращает true если массив пуст и false сли нет.
    .max()                              Максимальный элемент
    .min()                              Минимальный элемент
    .forEach {переменная in действие}   Замыкание, которое перебирает переменные и применяе к каждой действие
        friendsNames.forEach { fr in print("\(fr) still my friend") }
    .suffix(3)                          Вернет массив состоящий из трёх последних элементов.
    .first                              Вернет первый элемент массива
    .last                               Вернет последний элемент массива
    .dropFirst()                        Вернет миссив без первого элемента (не меняет исходный массив)
    .dropLast(4)                        Вернет миссив без 4 последних элементов (не меняет исходный массив)
    .contains(элемент)                  Проверяет наличие данного элемента. (возвращает true или false)
    .sort()                             Сортирует оригинальный массив по возрастанию.
    .sorted()                           Возвращает отсортированный массив не меняю оригинального.
    .randomElement()                    Вернет случайный элемент массива.
    .enumerated()                       Возвращает последовательность кортежей (индексЭлемента, элемент)
                                        for (n, c) in "Swift".enumerated() {
                                            print("\(n): '\(c)'")
                                        }
 
 
 
 
 
 Set=====================================================================
    
 1. Неупорядоченый набор элементов одного типа, каждый из которых может встречаться только один раз.

Обявление и инициализация:
    var evenNumbers = Set([2, 4, 6, 8])
    let oddNumbers: Set = [1, 3, 5, 7, 9, 9]
    let oddNumbers: Set<Int> = [1, 3, 5, 7, 9, 9]
    let mySet = Set<Int>(arrayLiteral: 5, 66, 12)
    let mySet = Set(arrayLiteral: 5, 66, 12)
    let emptySet = Set<String>()
 
Операции с множествами:
    множество1.intersection(множество2) Вернет новое множество которое будет содержать общие элементы
                                        для множества1 и множества2.
    множество1.symmetricDifference(множество2) Вернет новое множество которое будет содержать необщие
                                               элементы для множества1 и множества2.
    множество1.union(множество2)        Вернет новое множество которое будет содержать все элементы
                                        множества1 и множества2 в еденичном экземпляре.
    множество1.subtracting(множество2)  Вернет новое множество которое будет содержать все элементы
                                        множества1 которых нет в множестве2.
 
Отношения множеств:
    ==                                  Мгожества считаются эквивалентны если имеют одинаковый набор
                                        элементов.
    множество1.isSubset(множество2)     Вернет true если множество1 - это подмножество множества2
    множество1.isDisjoint(множество2)   Вернет true если множество1 не содержит элементов множества2
 

 
Методы:
    .insert(значение)                   Добавляет значение если его еще нет в множестве иначе ничего не                                     произойдет. Возвращает (Bool, тип), где Bool - это успешность                                       инициализации, а Тип - это значение того типа котороеприсваивается.
    .remove(занчение)                   Удаляет значение если его еще нет в множестве иначе ничего не                                       произойдет. Возвращает уничтоженное значение или nil если такого                                    значения нет.
    .removeAll()                        Удаляет все элементы множества.
    .contains(_:)                       Проверяет наличие эллемента и возврщает Bool.
    .count                              Возвращает колличество эллементов.
    .sorted()                           Отсортирует множество по возростанию и вернет массив Array<тип>.
 
 
 
 Dictionary==============================================================
 
1. Неупорядоченный набор пар (ключ: значение) при этом, как все ключи, так и все значения должны быть
   однотипные, но при этом тип ключа должен быть хешируем.
 
Обявление и инициализация:
    var scores = ["Paris": 5, "Marina": 10, "Tim": 9, "Jon": 14]
    let scores: [String: Int] = ["Paris": 5, "Marina": 10, "Tim": 9, "Jon": 14]
    let dictOne: Dictionary<Int,Bool> = [100: false, 200: true, 400: true]
    var birthYears = [1991: ["John", "Ann", "Vasiliy"], 1993: ["Alex", "Boris"] ]
    var scores: [String: Int] = [:]
    var dic =  Dictionary<String,Int>()
    let newDictionary = Dictionary(dictionaryLiteral: (100, "Сто"), (200, "Двести"), (300, "Триста"))
        Даннаяфункция возвращает словарь. Dictionary(dictionaryLiteral: )
    let newDictionary = Dictionary(uniqueKeysWithValues: baseCollection) Данная функциявозвращает словарь
        на основе кортежа. baseCollection - это кортеж.
 
Взаимодействие с элементами словоря:
    scores["Bob"] = 17
    print(scores["Paris"]!)                // 5
 
Методы:
    .updateValue(17, forKey: "Bob") Добавляем или изменяем существующее значение. Возвращает старое
        значение либо nil.
    .removeValue(forKey:)           Удаляет пару (Значение: Ключ). Возвращяет удалённое значение или
                                    nil если такого значения не было.
    .count                          Возвращает колличество элементов.
    .isEmpty                        Пуст true, непуст false.
    .keys                           Вернёт все ключи словаря.
    .values                         Вернёт все значения словаря.
 
 
 
 Tuples==================================================================
 
1. Упорядоченый набор элементов одного или разных типов, типы и колличесво которых известны зарание.
2. Не рекомендуется использовать более 4 значений.
3. Сравнение картежа произвонится в случае если типы его элементов являются Comparable и они идентичны
   и сравнение происходит начиная с первого элемента пока не будут достигнуты разные элементы.
 
Обявление и инициализация:
    let props = (22, "age")                В данном случае можно обратиться к элементам кортежа
                                           по номеру, как в массиве point.0    // 22
    var userInfo: (Bool, Int, String) = (true, 34, "Tom")
    var userInfo: (status: Bool, age: Int, name: String) = (true, 34, "Tom")
    var point(x: 2, y: 8)                  В данном случае можно обратиться к элементам кортежа,
                                           как по номеру, так и по псевдониму point.y    // 8
    var point1: (Int, Int) = point         Однотипные картежи можно инициализировать доруг другу.
 
Передача значений элементов картежв в другие параметры:
    var (isHomeless, age, name) = userInfo Передаст в каждую переменную значение в соответствии
                                           с очередностью
    var (isHomeless, _, name) = userInfo  В данном случае элемент age будет проигнорирован.
 
Методы:
 
 
 
 Range===================================================================
 
1. Диапазон МОЖНО сравнить на эквивалентность == или !=, но НЕЛЬЗЯ сравнить >, <, >=, <=
 
Обявление и инициализация:
    let someRangeInt: Range<Int> = 1..<10
    let someRangeInt = 1..<10
    let someRangeInt: Range<Double> = 1..<10
    let someRangeInt = 1.2..<10.7
    let range = UInt8(1)...                // от 1 до +inf (но не более 255 иначе ошибка)
 
    1...4                                  // 1, 2, 3, 4
    1..<5                                  // 1, 2, 3, 4
    ...43                                  // от -inf до 43
    -21...                                 // от -21 до +inf
    переменная1...переменная2              // от переменная1 до переменная2
 
Методы:
    .contains(32)                          Проверяет содержит ли диапазон число 32.
    .count                                 Определяет колличество элементов.
                                           (только целочисленный диапазон)
    .isEmpty                               Вернет true только в полуоткрытом диапазоне
                                           0..<0 или 23..<23
    .lowerBound                            Нижняя граница
    .upperBound                            Верхняя граница (и если ..<12 и если ...12)    //12
    .min()                                 Минимальное значение (только целочисленный диапазон)
    .max()                                 Максимальное значение (только целочисленный диапазон)
 

 
 String==================================================================
 
 1. Графем-кластер - это совокупность юникод-скаляров ("\u{65}\u{301}"  =  е[с ударением])
 2. Юникод-скаляр (кодовая точка) - это запись символом кодом (\u{E9}  =  е[с ударением])
 3. Графем кластеры могут определять, как символыё, так и эмодзи.
 4. Каждый символ, помимо кодовой точки, также имеет уникальное название. Эти данные при необходимости
    можно найти в таблицах юникод-символов в интернете.
 5. String - это коллекция символовв, каждый из которых является графем-кластером.
 6. С помощью оператора полуоткрытого диапазона можно получить доступ к элементам строки
    после определенного элемента.
 
Объявление и инициализация:
     var str = "строка"
     var str: String = ""
 
Методы:
    .count                                 Колличество элементов.
    .startIndex                            Возвращает значение типа String.Index позволяющее получить
                                           доступ именно к графем-кластеру на пример так:
                                           let index = name.startIndex
                                           arr[index]           // символ Character
    .endIndex                              Индекс элемента следующего за последним элемента.
    .index(before:)                        Индекс элемента предшествующего элементу, индекс которого
                                           передан в качестве аргумента.
    .index(after:)                         Индекс элемента следующиего за элементом, индекс которого
                                           передан в качестве аргумента.
    .index(_: индексЭлемента, offsetBy: отступ[целое число]) Возвращает индекс элемента на позиции
                                                             отступа от индексЭлемента.
    .unicodeScalars                        Доступ к юникод-скалярам строкиНапример посчитать элементы
                                           str.unicodeScalars.count
 
 
    
 
 */

